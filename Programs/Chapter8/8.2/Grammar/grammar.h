/***************************************************************
*  Структуры и алгоритмы обработки данных:                     *
*  объектно-ориентированный подход и реализация на C++         *
*      Глава 8. Функции как носитель информации                *
*          8.2. Задача о расстановке ферзей на шахматной доске *
*               и другие задачи                                *
*                                                              *
*  Автор    : А.Кубенский                                      *
*  Файл     : grammar.h                                        *
*  Описание : Классы для описания грамматик и заголовки        *
*             операторов над языками                           *
***************************************************************/

#ifndef __GRAMMAR_H
#define __GRAMMAR_H

#include <string>
#include "smartptr.h"

using namespace std;

//--------------------------------------------------------------
// Класс Lang определяет множество слов (язык).
// Предполагается, что язык определяется с помощью грамматик
// регулярных выражений, задаваемых с помощью стандартных средств:
// - выражение, задаваемое словом, состоящим из одной буквы;
// - альтернация двух выражений;
// - катенация двух выражений;
// - итерация выражения.
// Для всех этих средств предусмотрены соответствующие операции.
//--------------------------------------------------------------
class Lang {
public :
  virtual ~Lang() {}
  virtual bool contains(const string & word) const = 0;
};

//--------------------------------------------------------------
// Операции над языками.
// Результатом всегда служит указатель на вновь построенный язык.
//--------------------------------------------------------------

// Специальная операция: вычленение префикса. Результирующий язык
// содержит множество таких слов, что если к этому слову добавить
// заданный префикс, то оно будет содержаться в исходном языке.
SmartPtr<Lang> operator ^ (const SmartPtr<Lang> & lang,
                           const string & prefix);

// Операция альтернации (объединения) языков.
// --- на языке регулярных выражений: ex1 | ex2
SmartPtr<Lang> operator | (const SmartPtr<Lang> & lang1,
                           const SmartPtr<Lang> & lang2);

// Операция катенации языков.
// --- на языке регулярных выражений: ex1 ex2
SmartPtr<Lang> operator & (const SmartPtr<Lang> & lang1,
                           const SmartPtr<Lang> & lang2);

// Операция итерации (катенация с собой неотрицательное число раз).
// --- на языке регулярных выражений: ex*
SmartPtr<Lang> operator ~ (const SmartPtr<Lang> & lang);

// Специальная операция: добавление одного слова в язык
SmartPtr<Lang> operator + (const SmartPtr<Lang> & lang,
                           const string & word);

// Специальная операция: удаление одного слова из языка
SmartPtr<Lang> operator - (const SmartPtr<Lang> & lang,
                           const string & word);

// Добавление в язык пустого слова.
// --- на языке регулярных выражений: [ex]
SmartPtr<Lang> operator + (const SmartPtr<Lang> & lang);

//--------------------------------------------------------------
// Класс OneWordLang определяет язык, состоящий из
// единственного слова, задаваемого конструктором.
//--------------------------------------------------------------
class OneWordLang : public Lang {
  string word;  // Слово, представляющее язык

public :

  // Конструктор языка запоминает слово
  OneWordLang(const string & word) : word(word) {}

  // Функция проверки принадлежности просто сравнивает слово с "эталоном"
  bool contains(const string & w) const {
    return w == word;
  }
};

//--------------------------------------------------------------
// Класс OneLetterLang определяет язык, состоящий из единственного
// слова, содержащего единственную букву, задаваемую конструктором.
//--------------------------------------------------------------
class OneLetterLang : public Lang {
  string word;  // Слово, представляющее язык

public :

  // Конструктор языка запоминает слово
  OneLetterLang(char c) { word += c; }

  // Функция проверки принадлежности просто сравнивает слово с "эталоном"
  bool contains(const string & w) const {
    return w == word;
  }
};

//--------------------------------------------------------------
// Класс PlusWordLang добавляет в заданный язык заданное слово.
//--------------------------------------------------------------
class PlusWordLang : public Lang {
  SmartPtr<Lang> lang;   // Ссылка на исходный язык
  string word;           // Добавленное слово

public :

  // Конструктор просто запоминает параметры
  PlusWordLang(const SmartPtr<Lang> & lang, const string & word)
    : lang(lang), word(word) {}

  // Функция проверки принадлежности: заданное слово должно
  // совпадать с добавленным или принадлежать исходному языку.
  bool contains(const string & w) const {
    return w == word || lang->contains(w);
  }
};

//--------------------------------------------------------------
// Класс MinusWordLang удаляет из заданного языка заданное слово.
//--------------------------------------------------------------
class MinusWordLang : public Lang {
  SmartPtr<Lang> lang;   // Ссылка на исходный язык
  string word;           // Удаляемое слово

public :

  // Конструктор просто запоминает параметры
  MinusWordLang(const SmartPtr<Lang> & lang, const string & word) : lang(lang), word(word) {}

  // Функция проверки принадлежности: заданное слово должно
  // не совпадать с удаленным и принадлежать исходному языку.
  bool contains(const string & w) const {
    return w != word && lang->contains(w);
  }
};

//--------------------------------------------------------------
// Класс AltLang определяет альтернацию (объединение) двух языков
//--------------------------------------------------------------
class AltLang : public Lang {
  SmartPtr<Lang> lang1,
                 lang2;   // Исходные языки

public :

  // Конструктор просто запоминает ссылки на два исходных языка
  AltLang(const SmartPtr<Lang> & lang1, const SmartPtr<Lang> & lang2)
    : lang1(lang1), lang2(lang2) {}

  // Функция проверки принадлежности: слово принадлежит объединению,
  // если оно принадлжит хотя бы одному из объединяемых языков.
  bool contains(const string & word) const {
    return lang1->contains(word) || lang2->contains(word); 
  }
};

//--------------------------------------------------------------
// Класс PrefixLang определяет новый язык
// по исходному языку lang и префиксу prefix следующим образом.
// Из исходного языка выбираются все слова, начинающиеся на
// заданный префикс, после чего этот префикс из слов убирается.
// Получившееся множество слов и образует новый язык.
//--------------------------------------------------------------
class PrefixLang : public Lang {
  SmartPtr<Lang> lang;   // Ссылка на исходный язык
  string prefix;         // Заданный префикс

public :

  // Конструктор просто запоминает параметры
  PrefixLang(const SmartPtr<Lang> & lang, const string & prefix)
    : lang(lang), prefix(prefix) {}

  // Функция принадлежности очень проста: слово принадлежит ноовму языку,
  // если после добавления префикса слово принадлежит исходному языку.
  bool contains(const string & word) const {
    return lang->contains(prefix + word); 
  }
};

//--------------------------------------------------------------
// Класс CatLang определяет катенацию двух языков
//--------------------------------------------------------------
class CatLang : public Lang {
  SmartPtr<Lang> lang1,
                 lang2;   // Исходные языки

public :

  // Конструктор просто запоминает ссылки на два исходных языка
  CatLang(const SmartPtr<Lang> & lang1, const SmartPtr<Lang> & lang2)
    : lang1(lang1), lang2(lang2) {}

  // Функция принадлежности слова языку
  bool contains(const string & word) const {
    // Если слово пусто, то оно может быть катенацией только
    // двух пустых слов
    if (word == "") {
      return lang1->contains(word) && lang2->contains(word);
    }

    // Непустое слово можно представить как катенацию пустого
    // слова и себя самого...
    if (lang1->contains("") && lang2->contains(word)) {
      return true;
    }

    // ... или слово можно представить как катенацию первой буквы...
    string first(word.substr(0,1));
    // ... и остатка слова.
    string last(word.substr(1));

    // Вычленим первую букву слова из первого языка и рекурсивным
    // вызовом операции катенации построим новый язык, которому
    // для анализа будем предъявлять слово без первой буквы.
    return ((lang1 ^ first) & lang2)->contains(last);
  }
};

//--------------------------------------------------------------
// Класс IterLang определяет итерацию языка
//--------------------------------------------------------------
class IterLang : public Lang {
  SmartPtr<Lang> lang;   // Ссылка на исходный язык

public :

  // Конструктор запоминает исходный язык
  IterLang(const SmartPtr<Lang> & lang) : lang(lang) {}

  // Функция проверки принадлежности слова языку основана на
  // уже определенных ранее операциях
  bool contains(const string & word) const {
    // Прежде всего проверяем, не принадлежит ли слово исходной грамматике
    if (lang->contains(word)) return true;

    // Теперь удаляем пустое слово из исходного языка, чтобы не зациклиться,
    // и строим катенацию этого языка с самой итерацией (это рекурсия!)
    // После этого можно проверить исходное слово на принадлежность
    // получившемуся результату
    return ((lang - "") & SmartPtr<Lang>(new IterLang(lang)))->contains(word);
  }
};

#endif
