/***************************************************************
*  Структуры и алгоритмы обработки данных:                     *
*  объектно-ориентированный подход и реализация на C++         *
*      Глава 1. Способы представления структур данных          *
*          1.3. Деревья                                        *
*                                                              *
*  Автор    : A.Кубенский                                      *
*  Файл     : tree.h                                           *
*  Описание : Рекурсивное определение дерева и метода для      *
*             вычисления его высоты.                           *
***************************************************************/

#ifndef __TREE_H
#define __TREE_H

#include <ctype.h>

//**************************************************************
// Шаблон классов Tree
//**************************************************************

template <class T>
class Tree {
  T item;             // содержимое корневого узла дерева
  Tree<T> *son;       // указатель на "старшего" сына
  Tree<T> *brother;   // указатель в список сыновей

public :

  // Конструктор корневого узла получает в качестве аргументов
  // содержимое этого узла и два указателя на дерево-сына и дерево-брата
  Tree(const T & item, Tree<T> *s = NULL, Tree<T> *b = NULL);

  // Деструктор освобождает память, занятую поддеревьями этого узла
  ~Tree();

  // Метод для вычисления высоты дерева
  int height();
};    // Конец определения класса Tree

// Далее следуют шаблонные функции, реализующие операции над деревом

// Конструктор узла дерева.
template <class T>
Tree<T>::Tree(const T & item, Tree<T> *son, Tree<T> *brother) {
  Tree<T>::item = item;
  Tree<T>::son = son;
  Tree<T>::brother = brother;
}

// Деструктор освобождает память, занятую
// поддеревьями этого узла и его братьями.
template <class T>
Tree<T>::~Tree() {
  if (son) delete son;
  if (brother) delete brother;
}

// Рекурсивная функция вычисления высоты.
template <class T>
int Tree<T>::height() {
  // В цикле вычисляются высоты всех сыновей данного узла
  // и выбирается максимальная из этих высот
  int max = 0;
  for (Tree<T> *current = son; current; current = current->brother) {
    int curHeight = current->height();
    if (curHeight > max) max = curHeight;
  }
  // К результату добавляется единица за счет самого корневого узла
  return max + 1;
}

#endif
