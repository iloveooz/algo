/***************************************************************
*  Структуры и алгоритмы обработки данных:                     *
*  объектно-ориентированный подход и реализация на C++         *
*      Глава 2. Базовые алгоритмы                              *
*          2.2. Сортировка и поиск в массивах                  *
*                                                              *
*  Автор    : А.Кубенский                                      *
*  Файл     : merge.h                                          *
*  Описание : Функция слияния двух упорядоченных массивов      *
*             в один                                           *
***************************************************************/

#ifndef __MERGE_H
#define __MERGE_H

//-------------------------------------------------------------
// Шаблон merge задает функцию слияния двух упорядоченных
// массивов в один результирующий.
//   - Key - класс, задающий тип элементов массива;
//   - arr1, arr2 - исходные упорядоченные массивы;
//   - low1, high1, low2, high2 - индексы, задающие диапазоны слияния;
//   - arr3 - буфер для результирующих элементов;
//   - low3 - нижний индекс в результирующем буфере.
//-------------------------------------------------------------

template <class Key>
void merge(Key * arr1, int low1, int high1,
           Key * arr2, int low2, int high2,
           Key * arr3, int low3) {
  // Предполагается, что в начале работы исходные массивы
  // упорядочены по крайней мере в своих фрагментах
  // arr1[low1:high1] и arr2[low2:high2].
  // В результате работы получается упорядоченный массив
  // arr3[low3:low3+(high1-low1)+(high2-low2)+1]
  int ndx1 = low1,   // Индекс в первом массиве
      ndx2 = low2,   // Индекс во втором массиве
      ndx3 = low3;   // Индекс в результирующем массиве
  // 1. Сначала происходит сляние, пока не будут
  //    перенесены все элементы одного из массивов
  while (ndx1 <= high1 && ndx2 <= high2) {
    if (arr1[ndx1] < arr2[ndx2]) {
      arr3[ndx3++] = arr1[ndx1++];
    } else {
      arr3[ndx3++] = arr2[ndx2++];
    }
  }

  // 2. Затем переносится остаток элементов второго массива
  if (ndx1 > high1)
    while (ndx2 <= high2) arr3[ndx3++] = arr2[ndx2++];
  else
    while (ndx1 <= high1) arr3[ndx3++] = arr1[ndx1++];
}

#endif
