/***************************************************************
*  Структуры и алгоритмы обработки данных:                     *
*  объектно-ориентированный подход и реализация на C++         *
*      Глава 2. Базовые алгоритмы                              *
*          2.2. Сортировка и поиск в массивах                  *
*                                                              *
*  Автор    : А.Кубенский                                      *
*  Файл     : mergesort.h                                      *
*  Описание : Функции сортировки элементов массива методом     *
*             последовательного слияния                        *
***************************************************************/

#ifndef __MERGE_SORT_H
#define __MERGE_SORT_H

#include "merge.h"
#include <math.h>

//-------------------------------------------------------------
// Шаблон move задает вспомогательную функцию, которая просто
// переносит элементы массива из одного фрагмента массива
// в другой фрагмент того же самого или другого массива.
//   - Key - класс, задающий тип элементов массива;
//   - src - исходный фрагмент массива;
//   - sLow, sHigh - индексы, задающие диапазон в исходном массиве;
//   - dst - результирующий фрагмент массива;
//   - dLow - индекс, задающий нижнюю границу результирующего массива.
//-------------------------------------------------------------

template <class Key>
void move(Key * src, int sLow, int sHigh, Key * dst, int dLow) {
  for (int pSrc = sLow, pDst = dLow; pSrc <= sHigh; ) {
    dst[pDst++] = src[pSrc++];
  }
}

//-------------------------------------------------------------
// Шаблон mergeSort задает функцию сортировки элементов
// массива методом последовательнго слияния.
//   - Key - класс, задающий тип элементов массива;
//   - array - упорядочиваемый массив;
//   - low, high - индексы, задающие диапазон сортировки;
//-------------------------------------------------------------

template <class Key>
void mergeSort(Key * array, int low, int high) {
  // Предполагается, что в начале работы low <= high
  // В результате сортировки получается упорядоченный фрагмент
  // массива в диапазоне от low до high
  int n = high - low + 1;    // Длина массива
  int frag = n;              // Число упорядоченных фрагментов
  int len = 1;               // Длина сливаемых фрагментов
  Key * source = array,      // Массив, из которого происходит слияние
      * dest = new Key[n];   // Массив, в который происходит слияние
  int sourceLow = low,       // Нижняя граница индексов массива-источника
      destLow = 0;           // Нижняя граница индексов массива-назначения

  while (frag > 1) {
    // Один шаг цикла слияния состоит в попарном слиянии фрагментов
    // исходного массива и переносе оставшихся неслитыми элементов
    // из исходного массива в результирующий.
    int pSource = sourceLow, pDest = destLow;
    do {
      int nextSource = min(pSource + 2*len, sourceLow + n);
      if (nextSource > pSource + len) {
        merge<Key>(source, pSource, pSource+len-1,
                   source, pSource+len, nextSource-1,
                   dest, pDest);
      } else {
        move<Key>(source, pSource, nextSource-1,
                  dest, pDest);
      }
      pSource = nextSource; pDest += 2*len;
    } while (pSource < sourceLow+n);
    len *= 2;
    frag = (frag+1)/2;
    Key * tempArray = dest; dest = source; source = tempArray;
    int tempLow = destLow; destLow = sourceLow; sourceLow = tempLow;
  }
  if (source != array) {
    move<Key>(source, sourceLow, sourceLow+n-1, dest, destLow);
  }
}

#endif
