/***************************************************************
*  Структуры и алгоритмы обработки данных:                     *
*  объектно-ориентированный подход и реализация на C++         *
*      Глава 7. Обмен сообщениями и обработка сообщений        *
*          7.2. Об одном способе вычисления конечных сумм      *
*                                                              *
*  Автор    : А.Кубенский                                      *
*  Файл     : emember.cpp                                      *
*  Описание : Реализация поведения члена суммы ряда для        *
*             приближенного вычисления значения числа е        *
***************************************************************/

#include "emember.h"
#include "summator.h"
#include <stdlib.h>

//--------------------------------------------------------------
// Генератор порождает сообщение о готовом значении, только если
// номер члена ряда равен нулю или уже готово значение
// предыдущего члена суммы. Сообщение порождается только один раз.
//--------------------------------------------------------------
Message * EMember::generate() {
  // Проверка, не было ли уже порождено сообщение
  if (generated) return NULL;

  if (number == 0) {
    // Для нулевого члена суммы значение порождается сразу же
    generated = true;
    return new SumMessage(MemberValue(0, 1));
  } else if (accepted) {
    // Предыдущий член суммы уже вычислен;
    // вычисляем значение данного члена суммы на его основе
    generated = true;
    return new SumMessage(MemberValue(number, pred / number));
  } else {
    // Пока еще нельзя выдать значение члена суммы;
    return NULL;
  }
}

//--------------------------------------------------------------
// Обработчик принимает значение некоторого члена суммы, и
// если номер этого члена ровно на единицу меньше собственного
// номера, запоминает его для дальнейшего вычисления.
//--------------------------------------------------------------
bool EMember::handle(const Message & msg) {
  // Проверка, не было ли уже запомнено значение предыдущего члена
  if (accepted) return false;

  // Проверка класса сообщения
  if (msg.getMsgClass() != SumMessage::msgMemberReady) return false;
  const SumMessage & myMsg = (const SumMessage &)msg;

  // Анализ и запоминание параметра сообщения
  MemberValue value = myMsg.getValue();
  if (value.getNumber() == number-1) {
    pred = value.getValue();
    accepted = true;
  }

  // Во всех случаях сообщение передается дальше для анализа его 
  // другими обработчиками (на самом деле это значение может 
  // понадобиться разве что сумматору).
  return false;
}
